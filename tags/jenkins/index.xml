<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins on ServiceMesher</title>
    <link>https://servicemesher.github.io/tags/jenkins/</link>
    <description>Recent content in Jenkins on ServiceMesher</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 04 Jun 2018 11:33:16 +0800</lastBuildDate>
    
	<atom:link href="https://servicemesher.github.io/tags/jenkins/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用 Minikube-in-a-Container 和 Jenkins 构建 Istio</title>
      <link>https://servicemesher.github.io/blog/building-istio-with-minikube-in-a-container-and-jenkins/</link>
      <pubDate>Mon, 04 Jun 2018 11:33:16 +0800</pubDate>
      
      <guid>https://servicemesher.github.io/blog/building-istio-with-minikube-in-a-container-and-jenkins/</guid>
      <description>原文链接：https://blog.aspenmesh.io/blog/2018/01/building-istio-with-minikube-in-a-container-and-jenkins/
作者：Andrew Jenkins
译者：戴佳顺
 AspenMesh提供一种Istio的分布式架构支持，这意味着即使与上游Istio项目无关，我们也需要能够测试和修复Bug。为此我们已开发构建了我们自己的打包和测试基础架构方案。如果你对Istio的CI（持续集成）也感兴趣，请参考我们已经投入使用，可能有用但还没有提交给Circle CI或GKE的组件。
这篇文章描述的是我们如何制作一个新的Minikube-in-a-Container容器和使用Jenkins Pipeline来构建和测试Istio的流程脚本。如果你觉得有必要，你可以通过docker run上运行minikube容器，然后在容器中部署功能性的kubernetes集群，不需要使用时可随时删除。Jenkins bits现在可帮助你构建Istio，也可以作为初始环境，以便在容器内构建容器。
Minikube-in-a-container 这部分描述了我们如何构建一个可以在构建过程中用来运行Istio冒烟测试的Minikube-in-a-container镜像。我们最初不是这么想的，我们最初使用本地localkube环境。我们不能让它在特定环境外工作，我们认为这是由于localkube和minikube之间有一点差异导致的。所以这是一个作为我们修复它使它能正常工作的记录。我们还添加了一些额外选项和工具，以便在生成的容器中使用Istio。这没有什么太多花样，但如果你要做类似的事情，我们希望它给你启发。
Minikube可能对你来说是一个可以在随身携带的笔记本上通过虚机运行自己kubernetes集群的非常熟悉的项目。这种方法非常方便，但在某些情况下（比如不提供嵌套虚拟化的云提供商），你就不能或者不希望基于虚机来完成了。由于docker现在可以运行在docker内部，我们决定尝试在docker容器内制作我们自己的kubernetes集群。一个非持久性的kubernetes容器很容易启动，也可进行一些测试，并在完成后进行删除。同时这也非常适合持续集成。
在我们的模型方案中，Kubernetes集群创建子docker容器（而不是Jérôme Petazzoni所提到的兄弟容器方案）。我们是故意这样做的，宁愿隔离子容器，而不是共享Docker构建的缓存。但是你应该在将你应用改造为DinD（docker in docker）之前阅读Jérôme的文章，也许DooD（在docker out of docker）是对你而言更好的方案。这篇文章供你参考。我们避免架构“变得更坏”的同时，对看起来“坏”和“丑”部分也应进行避免。
当你启动docker容器时，会要求docker在OS内核中创建和设置一些命名空间（namespaces），然后在通过这些命名空间启动你的容器。命名空间像一个沙箱：当你在命名空间中（即通过命名空间隔离），通常只能看到命名空间内的东西。chroot命令，不仅影响文件系统，还影响PID，网络接口等。如果你通过 --privileged 参数启动了一个docker容器，那么所涉及的命名空间隔离将获得额外的权限，比如创建更多子命名空间隔离的能力。这是完成docker-in-docker（即在docker中运行docker）的核心技巧。有关更多细节，Jérôme是这方面的专家，请在这里关注他的详细说明。
总之，这就是大致步骤：
 构建一个容器环境，完成docker，minikube，kubectl和依赖项的安装。
 添加一个假的systemctl shim来欺骗Minikube在没有真正安装systemd的环境中运行。
 使用 --privileged 参数启动容器
 让容器启动它自己内部的dockerd，这就是DinD的一部分。
 让容器通过参数 minikube --vm-driver = none 启动minikube，以便在容器中的minikube可以与与之一起运行的dockerd连接。
  所有你需要做的就是通过 docker run --privileged 运行容器，接着你就可以去使用kubectl了。这时如果你愿意，你可以在容器内运行kubectl，并得到一个真正的用完可随时删除的环境。
你现在可以试试它：
docker run --privileged --rm -it quay.io/aspenmesh/minikube-dind docker exec -it &amp;lt;container&amp;gt; /bin/bash # kubectl get nodes &amp;lt;....&amp;gt; # kubectl create -f https://k8s.</description>
    </item>
    
  </channel>
</rss>